<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="IBM WebSphere Studio Homepage Builder Version 7.0.0.0 for Windows">
<META http-equiv="Content-Style-Type" content="text/css">
<TITLE>ハッシュ・メッセージダイジェスト (overview) </TITLE>
<LINK rel="stylesheet" href="../../css/nitro.css" type="text/css">
</HEAD>
<BODY>
<H1 align="left">ハッシュ・メッセージダイジェスト (overview) </H1>
<H2>説明</H2>
<P><B>ハッシュとは</B></P>
<P>
任意のサイズのデータに対して、特定の演算を施すことによって、一定のビット数の数値に変換する手順をハッシュ関数と呼び、ハッシュ関数で計算した数値をハッシュ値と呼びます。
ハッシュ関数は、同じデータに対しては常に同じハッシュ値を返すように設計します。
</P>
<P><B>ハッシュの用途</B></P>
<P>
大きなデータが多数あり、どれがどれと等しいかを確認する場合、総当りで全てのデータを比較すると時間がかかります。
こういった場合に、それぞれのデータのハッシュ値を取ってからそれらを比較する、という手法が有効です。<BR>
<B>ハッシュ値が異なるならば、もとのデータも異なります</B>ので、高い確率で短時間で不一致を見つけることができます。
ハッシュ値が等しいものに関しては、改めて元のデータを比較する必要があります（<B>ハッシュ値が等しくても元データが同じであるとは限りません</B>）が、
全体としては、比較に要する時間を大きく短縮することが可能です。
</P>
<P>
また、データが壊れていないかを確認することにもハッシュ値は用いることができます。<BR>
例えば、バックアップデバイスにセーブする際に、データの末尾にセーブデータ全体のハッシュ値を格納しておきます。
そうすると、ロード時にロードデータ全体のハッシュ値を取り、末尾に記録されていた数値と比較することによって、
データが壊れていないかどうかを確認することができます。<BR>
同様に、ネットワーク越しに送られてきたデータが壊れていないかの確認にも使えます。
</P>
<P><B>メッセージダイジェスト</B></P>
<P>
狭い意味でハッシュ関数を定義した場合、さらに一方向性というものが求められる場合があります。
一方向ハッシュ関数とは、ハッシュ値から元のデータが類推できないという性質を持つハッシュ関数で、ハッシュ値のサイズは最低でも80bit、用途によっては512bit程度となります。<BR>
一方向ハッシュ関数は、あるハッシュ値を与えられたときに、そのハッシュ値を生成する元データを求めることが不可能であるように設計されています。
ここで不可能というのは、現在の技術では計算するのに何万年といった時間がかかってしまうために、
計算することができないと見なすことができる、という意味です。<BR>
こうした一方向ハッシュ関数を改ざん検出に用いる場合、ハッシュ関数をメッセージダイジェスト関数、ハッシュ値をメッセージダイジェスト値と呼ぶことがあります。
</P>
<P><B>メッセージダイジェストを使用した改ざん検出</B></P>
<P>
メッセージダイジェスト値を用いると、悪意ある第三者によるデータの改ざんを防ぐことが可能になります。<BR>
メッセージダイジェスト値は固定長で短いため、安全な方法で配布することが容易です。
そして、メッセージダイジェスト値さえ安全に配布することができれば、
別に送った大きなデータのメッセージダイジェスト値がそれに一致すれば、
データのほうも正しいものが送受信できたことが分かります。
なぜならば、一方向性により、同じメッセージダイジェスト値を生成する偽データを
悪意ある第三者が作成することはできないからです。
</P>
<P><B>HMAC を使用した改ざん検出</B></P>
<P>
しかし、メッセージダイジェスト値をデータと一緒に送らないといけない場合はどうでしょう。<BR>
メッセージダイジェスト関数は、誰が使っても同じデータに対しては同じメッセージダイジェスト値を返します。
そのため、メッセージダイジェスト値をデータと一緒に送信する場合は、
悪意のある第三者が偽データと偽メッセージダイジェスト値をセットで送ってしまえば、
改ざんが出来てしまいますので、意味がありません。<BR>
そういった場合に、HMAC (Keyed Hashing for Message Authentication Code: メッセージ認証のための鍵付ハッシング)
を使用することができます。
HMAC は簡単に言えば、ハッシュ値をさらに暗号化する仕組みです。<BR>
HMAC 関数に、ハッシュ値を取りたいデータとデータサイズ、暗号化の鍵データと鍵サイズ、を渡すと、
鍵によって暗号化されたハッシュ値を得ることができます。
この値は、暗号化の鍵データを知らない限りは生成できませんので、
受信時に鍵付ハッシュ値が一致すれば、確かに鍵を知っている送信元が送ったデータである、と
確認することができます。<BR>
しかし、HMAC では送信側も受信側も同じ鍵を使用します（共有鍵方式）ので、
受信側のプログラムが何らかの手段で解析され、鍵が明らかになってしまうと、データを改ざんすることが可能になってしまいます。
これに対抗するためには、公開鍵方式の暗号化を利用した電子署名を導入する必要がありますが、
そのライブラリは NITRO-SDK には含まれていません。
</P>
<P><B>SDK に含まれるハッシュ関数</B></P>
<P>
NITRO-SDK では、（一方向ではない）ハッシュ関数として、以下のものを用意しています。
</P>
<TABLE border="1">
  <TR>
    <TH>8bit Checksum</TH>
    <TD>MATH_Checksum8*</TD>
    <TD>1の補数和の1の補数を 8bit 単位で計算します。</TD>
    <TD></TD>
  </TR>
  <TR>
    <TH>16bit Checksum</TH>
    <TD>MATH_Checksum16*</TD>
    <TD>1の補数和の1の補数を 16bit 単位で計算します。</TD>
    <TD>IP, TCP, UDP などで使用されている。</TD>
  </TR>
  <TR>
    <TH>CRC-8</TH>
    <TD>MATH_CRC8*</TD>
    <TD>8bit の CRC を計算します。生成多項式は x<sup>8</sup>+x<sup>2</sup>+x<sup>1</sup>+1。ビット反転はなし。初期値は0で、出力の not はありません。</TD>
    <TD></TD>
  </TR>
  <TR>
    <TH>CRC-16</TH>
    <TD>MATH_CRC16*</TD>
    <TD>16bit の CRC を計算します。生成多項式は x<sup>16</sup>+x<sup>15</sup>+x<sup>2</sup>+1。ビット反転はあり。初期値は0で、出力の not はありません。</TD>
    <TD>ARC, LHA などのツールで使用されている。</TD>
  </TR>
  <TR>
    <TH>CRC-16 / CCITT</TH>
    <TD>MATH_CRC16CCITT*</TD>
    <TD>16bit の CRC を計算します。生成多項式は x<sup>16</sup>+x<sup>12</sup>+x<sup>5</sup>+1。ビット反転はなし。初期値は0xffffで、出力の not はありません。</TD>
    <TD>CCITT X.25 規格などで定められており、各種規格の通信フレームで使用されている。</TD>
  </TR>
  <TR>
    <TH>CRC-32</TH>
    <TD>MATH_CRC32*</TD>
    <TD>32bit の CRC を計算します。生成多項式は x<sup>32</sup>+x<sup>26</sup>+x<sup>23</sup>+x<sup>22</sup>+x<sup>16</sup>+x<sup>12</sup>+x<sup>11</sup>+x<sup>10</sup>+x<sup>8</sup>+x<sup>7</sup>+x<sup>5</sup>+x<sup>4</sup>+x<sup>2</sup>+x<sup>1</sup>+1。ビット反転はあり。初期値は0xffffffffで、出力は not します。</TD>
    <TD>PKZIP, PNG, Ethernet などで使用されている。ISO 3309, RFC 2083 などを参照。</TD>
  </TR>
  <TR>
    <TH>CRC-32 / POSIX</TH>
    <TD>MATH_CRC32POSIX*</TD>
    <TD>32bit の CRC を計算します。生成多項式は x<sup>32</sup>+x<sup>26</sup>+x<sup>23</sup>+x<sup>22</sup>+x<sup>16</sup>+x<sup>12</sup>+x<sup>11</sup>+x<sup>10</sup>+x<sup>8</sup>+x<sup>7</sup>+x<sup>5</sup>+x<sup>4</sup>+x<sup>2</sup>+x<sup>1</sup>+1。ビット反転はなし。初期値は0で、出力は not します。</TD>
    <TD>POSIX 準拠 Unix の cksum コマンドで使用されている。POSIX 1003.2 (IEEE Std 1003.2-1992) で規定。</TD>
  </TR>
</TABLE>
<P>
checksum は CRC の倍程度高速ですが、データの順番が入れ替わっていても同じ値になるなど、ハッシュ関数としての性質は良くありません。
なお、SDK に収められている checksum 関数は、checksum 値を元のデータに加えて全体の checksum を取ると結果が 0 になる、という性質を有しています。
また、1 の補数の世界では 0xffff と 0 が同じ値を表すため、checksum 値が 0 だったときには 0xffff に置き換えることにしても、
（元データ＋checksum 値）の checksum が 0 になるという性質は変わりません。これを利用して、正常な checksum 値として 0 を使わないようにでき、
0 を null 値（未計算など）として使用することが可能です。詳しくは、一般の UDP Checksum の解説を参照してください。
</P>
<P>
CRC はデータ長が一定長以下の場合、あるビット数までの誤りであれば確実に発見できることを保証するような数学的な設計がされています。
例えば、CRC-16, CRC-16/CCITT はデータ長が CRC を含めて 32767 ビットまでの時に、任意の 3bit までの誤り、
もしくは 16bit までの連続した誤りを確実に検出することができます。もちろん、この条件が満たされなくても高い確率で誤りを検出します。
なお、CRC は誤り訂正の機能も持っていますが、検出にのみ使用されることが多く、訂正に使われることはあまりありません。<BR>
SDK では <A href="MATH_CalcCRC.html">MATH_CalcCRC16</A> と同じ結果を返す <A href="../../svc/SVC_GetCRC16.html">SVC_GetCRC16</A> も
用意していますが、MATH の CRC 関数では計算用のテーブルを事前に用意しておくことにより、処理を高速にしています。
</P>
<P>
なお、これらは一方向ハッシュ関数ではありませんので、同じハッシュ値になるようにデータを改ざんすることは容易です。
</P>
<P>
また、一方向ハッシュ関数としては、以下のものを用意しています。
</P>
<TABLE border="1">
  <TR>
    <TH>MD5</TH>
    <TD>MATH_MD5*</TD>
    <TD>メッセージダイジェスト値の長さは 128bit。</TD>
    <TD>インターネット上で広く使われている。RFC 1321 を参照。</TD>
  </TR>
  <TR>
    <TH>SHA-1</TH>
    <TD>MATH_SHA1*</TD>
    <TD>メッセージダイジェスト値の長さは 160bit。</TD>
    <TD>MD5 の後継として広く使われている。RFC 3174 を参照。</TD>
  </TR>
  <TR>
    <TH>HMAC-MD5</TH>
    <TD><A href="../dgt/MATH_CalcHMACMD5.html">MATH_CalcHMACMD5</A></TD>
    <TD>MD5 を利用した HMAC。メッセージダイジェスト値の長さは 128bit。</TD>
    <TD>RFC 2104 を参照。</TD>
  </TR>
  <TR>
    <TH>HMAC-SHA-1</TH>
    <TD><A href="../dgt/MATH_CalcHMACSHA1.html">MATH_CalcHMACSHA1</A></TD>
    <TD>SHA-1 を利用した HMAC。メッセージダイジェスト値の長さは 160bit。</TD>
    <TD>RFC 2104 を参照。</TD>
  </TR>
</TABLE>
<P>
MD5 は一方向ハッシュ関数として広く使われてきましたが、
研究が進み、特定の状況下での弱点が次々と報告されています。
そのため、現在では一方向ハッシュ関数としては SHA-1 が利用されることが多くなっています。
新規に一方向ハッシュ関数を利用する場合には、SHA-1 を使用したほうがよいでしょう。
</P>
<P>
なお、これらの一方向ハッシュ関数は、結果の途中までのビットだけを用いても十分にハッシュ値として使用できます。
（HMAC-SHA-1 を最初の 80bit だけ保存して使用する、など。）
当然のことながら、結果を切り詰めるほど、ハッシュとしての性質は悪化します。
</P>
<P><B>ハッシュ関数の速度比較</B></P>
<P>
SDK の dgt-2 デモは 1MB のランダムデータを各ハッシュ関数で処理した場合の所要時間を計測するデモです。
参考までに、出力サンプルを以下に示します。
なお、CRC のテーブル生成は時間に含まれておりません。
</P>
<P>
<PRE>
Checksum8:        80201 us/MB
Checksum16:       80174 us/MB
CRC-8:           182277 us/MB
CRC-16:          225972 us/MB
CRC-16/CCITT:    227036 us/MB
CRC-32:          196804 us/MB
CRC-32/POSIX:    196690 us/MB
MD5:             299266 us/MB
SHA-1:           591120 us/MB
HMAC-MD5:        299839 us/MB
HMAC-SHA-1:      591214 us/MB
CRC-16(SVC):     862306 us/MB
</PRE>
</P>

<H2>参照</H2>
<P><CODE>
<A href="../list_math.html#Hash">MATH関数一覧(ハッシュ値)</A>, <A href="../list_math.html#Digest">MATH関数一覧(メッセージダイジェスト)</A><BR>
</CODE></P>
<H2>履歴</H2>
<P>
2006/05/24 最近の動向を踏まえ、MD5 よりも SHA-1 のほうが望ましいことを明記<BR>
2005/07/08 SHA-1 の実装変更に伴い、dgt-2 デモの出力サンプルを更新<BR>
2005/06/24 MD5 の実装変更に伴い、dgt-2 デモの出力サンプルを更新<BR>
2005/04/18 初版<BR>
</P>
</BODY>
</HTML>